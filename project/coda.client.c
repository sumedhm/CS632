
/* DO NOT EDIT: generated by rp2gen from coda.rpc2 */
#ifdef __cplusplus
extern "C" {
#endif
#include <sys/time.h>
#ifdef __cplusplus
}
#endif

#include "coda.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <sys/types.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>


#ifdef __cplusplus
}
#endif

#define _PAD(n)	((((n)-1) | 3) + 1)


#if (coda_HEAD_VERSION != 1414748928)
; char *NOTE[] = CAUTION_______________________________________!!!VERSION_IS_INCONSISTENT_WITH_HEADER_FILE______!!!PLEASE_CHECK_YOUR_FILE_VERSION________________;
#endif

long coda_ElapseSwitch = 0;

long coda_EnqueueRequest = 1;

CallCountEntry coda_CallCount[] = {
	/* dummy */		{(RPC2_String)"dummy", 0, 0, 0, 0, 0},
	/* GetMsg_OP */	{(RPC2_String)"GetMsg", 0, 0, 0, 0, 0}
};

long VENUS_GetMsg(RPC2_Handle _cid, RPC2_Integer *arg)
{
    char *_ptr;
    long _length, _rpc2val, _code;
    RPC2_PacketBuffer *_rspbuffer = NULL;
    struct timeval _timestart, _timeend;
    RPC2_PacketBuffer *_reqbuffer = NULL;
    struct timeval *_timeout;
    char *_EOB;
    int opengate = 0;

    /* START_ELAPSE */
    coda_CallCount[1].countent++;
    if (coda_ElapseSwitch) {
	gettimeofday(&_timestart, NULL);
	opengate = 1;
    }

    _length = 0;
    _rpc2val = RPC2_AllocBuffer(_length, &_reqbuffer);
    if (_rpc2val != RPC2_SUCCESS) return _rpc2val;
    _EOB = (char *)_reqbuffer + _reqbuffer->Prefix.BufferSize;

    /* Avoid compiler warnings */
    _ptr = NULL;

    /* Generate RPC2 call */
    _reqbuffer->Header.Opcode = GetMsg_OP;
    _rspbuffer = NULL;
    _timeout = NULL;
    _rpc2val = RPC2_MakeRPC(_cid, _reqbuffer, NULL, &_rspbuffer, _timeout, coda_EnqueueRequest);
    RPC2_FreeBuffer(&_reqbuffer);
    if (_rpc2val != RPC2_SUCCESS) {
	RPC2_FreeBuffer(&_rspbuffer);
	return _rpc2val;
    }
    if (_rspbuffer->Header.ReturnCode == RPC2_INVALIDOPCODE) {
	RPC2_FreeBuffer(&_rspbuffer);
	return RPC2_INVALIDOPCODE;
    }

    /* Unpack arguments */
    _ptr = (char *)_rspbuffer->Body;
     _EOB = (char *)_rspbuffer + _rspbuffer->Prefix.LengthOfPacket + 
			sizeof(struct RPC2_PacketBufferPrefix);
    if ( (char *)_ptr + 4 > _EOB)
	goto bufferoverflow;
    *arg = ntohl(*(RPC2_Integer *) _ptr);
    _ptr += 4;
    _code = _rspbuffer->Header.ReturnCode;
    RPC2_FreeBuffer(&_rspbuffer);

    /* END_ELAPSE */
    if (opengate) {
	gettimeofday(&_timeend, NULL);
	coda_CallCount[1].tsec += _timeend.tv_sec - _timestart.tv_sec;
	coda_CallCount[1].tusec += _timeend.tv_usec - _timestart.tv_usec;
	if (coda_CallCount[1].tusec < 0) {
	    coda_CallCount[1].tusec += 1000000;
	    coda_CallCount[1].tsec--;
	} else if (coda_CallCount[1].tusec >= 1000000) {
	    coda_CallCount[1].tusec -= 1000000;
	    coda_CallCount[1].tsec++;
	}
	coda_CallCount[1].counttime++;
    }
    coda_CallCount[1].countexit++;

    return _code;

bufferoverflow:
    fprintf(stderr,"%s:%d Buffer overflow in (un)marshalling !\n",__FILE__,__LINE__);
    RPC2_FreeBuffer(&_rspbuffer);
    return RPC2_BADDATA;
}
